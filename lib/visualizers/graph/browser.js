/**
 * Graph Visualizer — Runtime (browser.js)
 *
 * Renders an interactive force-directed graph using force-graph (MIT).
 * Library loaded from CDN at runtime to avoid bundling ~300KB.
 *
 * Reads:
 *   /graph.json          — node + link data (always generated by preprocessor)
 *   /graph-settings.json — vault-wide defaults from .bloob/graph.yaml
 *
 * Per-page settings come from data attributes on .graph-visualizer containers:
 *   data-current-page    — this page's URL (e.g. "/recipes/chai/")
 *   data-page-settings   — JSON from frontmatter graph: key (set by layout template)
 *   data-graph-settings  — JSON from ```graph code fence (set by build-time transform)
 *   data-graph-position  — "inline" if set by code fence; absent for layout-placed containers
 */

const FORCE_GRAPH_CDN =
  "https://fastly.jsdelivr.net/npm/force-graph@1.43.0/dist/force-graph.min.js";

// ─── Settings ─────────────────────────────────────────────────────────────────

const DEFAULTS = {
  only_if_linked: true,
  depth: 2,
  show_full_graph: true,
  colors: {},
};

// ─── CDN loader ───────────────────────────────────────────────────────────────

function loadForceGraph() {
  return new Promise((resolve, reject) => {
    if (window.ForceGraph) {
      resolve(window.ForceGraph);
      return;
    }
    const script = document.createElement("script");
    script.src = FORCE_GRAPH_CDN;
    script.onload = () => resolve(window.ForceGraph);
    script.onerror = () =>
      reject(new Error("Failed to load force-graph from CDN"));
    document.head.appendChild(script);
  });
}

// ─── Data fetching (shared, cached) ───────────────────────────────────────────

let _graphDataPromise = null;
let _graphSettingsPromise = null;

function fetchGraphData() {
  if (!_graphDataPromise) {
    _graphDataPromise = fetch("/graph.json")
      .then((r) => r.json())
      .catch(() => ({ nodes: [], links: [] }));
  }
  return _graphDataPromise;
}

function fetchGraphSettings() {
  if (!_graphSettingsPromise) {
    _graphSettingsPromise = fetch("/graph-settings.json")
      .then((r) => r.json())
      .catch(() => ({}));
  }
  return _graphSettingsPromise;
}

// ─── CSS variable helpers ─────────────────────────────────────────────────────

function cssVar(name) {
  return getComputedStyle(document.documentElement)
    .getPropertyValue(name)
    .trim();
}

function resolveColors(overrides = {}) {
  return {
    node: overrides.node || cssVar("--accent-color") || "#d2691e",
    node_current: overrides.node_current || cssVar("--accent-dark") || "#8b4513",
    link: overrides.link || cssVar("--border-color") || "#e8dcc4",
    text: overrides.text || cssVar("--text-light") || "#666666",
    bg: overrides.bg || cssVar("--bg-color") || "#fffaf0",
  };
}

// ─── Graph filtering ──────────────────────────────────────────────────────────

/**
 * BFS to collect nodes within `depth` hops of currentUrl.
 * Traverses both outgoing and incoming links (undirected neighborhood).
 */
function getLocalGraph(graphData, currentUrl, depth) {
  // Normalise: graph.json stores URLs as-is; window.location.pathname may
  // differ by trailing slash. Normalise both to have trailing slash.
  const normalise = (u) => (u.endsWith("/") ? u : u + "/");
  const current = normalise(currentUrl);

  const visited = new Set([current]);
  let frontier = [current];

  for (let hop = 0; hop < depth; hop++) {
    const nextFrontier = [];
    for (const url of frontier) {
      for (const link of graphData.links) {
        const s = normalise(
          typeof link.source === "object" ? link.source.id : link.source,
        );
        const t = normalise(
          typeof link.target === "object" ? link.target.id : link.target,
        );
        const neighbor = s === url ? t : t === url ? s : null;
        if (neighbor && !visited.has(neighbor)) {
          visited.add(neighbor);
          nextFrontier.push(neighbor);
        }
      }
    }
    frontier = nextFrontier;
    if (frontier.length === 0) break;
  }

  const nodes = graphData.nodes.filter((n) => visited.has(normalise(n.id)));
  const nodeIds = new Set(nodes.map((n) => normalise(n.id)));
  const links = graphData.links.filter((l) => {
    const s = normalise(
      typeof l.source === "object" ? l.source.id : l.source,
    );
    const t = normalise(
      typeof l.target === "object" ? l.target.id : l.target,
    );
    return nodeIds.has(s) && nodeIds.has(t);
  });

  return { nodes, links };
}

// ─── Rendering ────────────────────────────────────────────────────────────────

function renderGraph(ForceGraph, container, graphData, currentUrl, settings) {
  const colors = resolveColors(settings.colors);
  const normalise = (u) => (u.endsWith("/") ? u : u + "/");
  const current = normalise(currentUrl);

  const localData = getLocalGraph(graphData, currentUrl, settings.depth);

  // Hide if only_if_linked and this page has no connections
  if (settings.only_if_linked && localData.nodes.length <= 1) {
    container.style.display = "none";
    return;
  }

  // --- Build container structure ---
  const header = document.createElement("div");
  header.className = "graph-header";

  const title = document.createElement("span");
  title.className = "graph-title";
  title.textContent = "Connections";
  header.appendChild(title);

  if (settings.show_full_graph) {
    const btn = document.createElement("button");
    btn.className = "graph-full-btn";
    btn.textContent = "Full graph";
    btn.addEventListener("click", () =>
      openFullGraph(ForceGraph, graphData, currentUrl, settings),
    );
    header.appendChild(btn);
  }

  const canvas = document.createElement("div");
  canvas.className = "graph-canvas";

  container.appendChild(header);
  container.appendChild(canvas);

  // --- Render with force-graph ---
  const width = container.offsetWidth || 500;
  const height = 220;

  const graph = ForceGraph()(canvas)
    .graphData(localData)
    .nodeId("id")
    .nodeLabel("title")
    .nodeColor((node) =>
      normalise(node.id) === current ? colors.node_current : colors.node,
    )
    .nodeRelSize(4)
    .linkColor(() => colors.link)
    .linkWidth(1)
    .backgroundColor(colors.bg)
    .width(width)
    .height(height)
    .nodeCanvasObjectMode(() => "after")
    .nodeCanvasObject((node, ctx, globalScale) => {
      const label = node.title || node.id;
      const fontSize = Math.max(8, 11 / globalScale);
      ctx.font = `${fontSize}px ${cssVar("--font-heading") || "sans-serif"}`;
      ctx.fillStyle = colors.text;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(label, node.x, node.y + 6);
    })
    .onNodeClick((node) => {
      window.location.href = node.id;
    })
    .d3AlphaDecay(0.1)
    .d3VelocityDecay(0.3);

  // Stop simulation after settling to save CPU
  setTimeout(() => graph.d3Force("charge", null), 3000);
}

function openFullGraph(ForceGraph, graphData, currentUrl, settings) {
  const colors = resolveColors(settings.colors);
  const normalise = (u) => (u.endsWith("/") ? u : u + "/");
  const current = normalise(currentUrl);

  // --- Modal structure ---
  const overlay = document.createElement("div");
  overlay.className = "graph-modal-overlay";

  const modal = document.createElement("div");
  modal.className = "graph-modal";

  const closeBtn = document.createElement("button");
  closeBtn.className = "graph-modal-close";
  closeBtn.setAttribute("aria-label", "Close full graph");
  closeBtn.textContent = "×";
  closeBtn.addEventListener("click", () => overlay.remove());

  const canvas = document.createElement("div");
  canvas.className = "graph-modal-canvas";

  modal.appendChild(closeBtn);
  modal.appendChild(canvas);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener("click", (e) => {
    if (e.target === overlay) overlay.remove();
  });

  document.addEventListener(
    "keydown",
    (e) => {
      if (e.key === "Escape") overlay.remove();
    },
    { once: true },
  );

  // Render after a tick so modal dimensions are known
  requestAnimationFrame(() => {
    const width = canvas.offsetWidth || modal.offsetWidth - 32 || 720;
    const height = canvas.offsetHeight || modal.offsetHeight - 56 || 520;

    ForceGraph()(canvas)
      .graphData(graphData)
      .nodeId("id")
      .nodeLabel("title")
      .nodeColor((node) =>
        normalise(node.id) === current ? colors.node_current : colors.node,
      )
      .nodeRelSize(4)
      .linkColor(() => colors.link)
      .linkWidth(1)
      .backgroundColor(colors.bg)
      .width(width)
      .height(height)
      .nodeCanvasObjectMode(() => "after")
      .nodeCanvasObject((node, ctx, globalScale) => {
        const label = node.title || node.id;
        const fontSize = Math.max(7, 10 / globalScale);
        ctx.font = `${fontSize}px ${cssVar("--font-heading") || "sans-serif"}`;
        ctx.fillStyle = colors.text;
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText(label, node.x, node.y + 5);
      })
      .onNodeClick((node) => {
        overlay.remove();
        window.location.href = node.id;
      })
      .d3AlphaDecay(0.08);
  });
}

// ─── Init ─────────────────────────────────────────────────────────────────────

async function init() {
  const containers = document.querySelectorAll(".graph-visualizer");
  if (containers.length === 0) return;

  let ForceGraph, graphData, siteSettings;
  try {
    [ForceGraph, graphData, siteSettings] = await Promise.all([
      loadForceGraph(),
      fetchGraphData(),
      fetchGraphSettings(),
    ]);
  } catch (e) {
    console.warn("[graph] Failed to initialise:", e.message);
    return;
  }

  for (const container of containers) {
    const currentUrl =
      container.dataset.currentPage || window.location.pathname;

    // Per-page settings from frontmatter (baked into layout template)
    let pageSettings = {};
    try {
      if (container.dataset.pageSettings) {
        pageSettings = JSON.parse(container.dataset.pageSettings);
      }
    } catch {}

    // Per-instance settings from ```graph code fence
    let instanceSettings = {};
    try {
      if (container.dataset.graphSettings) {
        instanceSettings = JSON.parse(container.dataset.graphSettings);
      }
    } catch {}

    // Merge: defaults ← site ← page ← instance (deepest wins)
    const settings = {
      ...DEFAULTS,
      ...siteSettings,
      ...pageSettings,
      ...instanceSettings,
      colors: {
        ...(siteSettings.colors || {}),
        ...(pageSettings.colors || {}),
        ...(instanceSettings.colors || {}),
      },
    };

    renderGraph(ForceGraph, container, graphData, currentUrl, settings);
  }
}

document.addEventListener("DOMContentLoaded", init);
