/**
 * Graph Visualizer — Runtime (browser.js)
 *
 * Renders an interactive force-directed graph using force-graph (MIT).
 * Library loaded from CDN at runtime to avoid bundling ~300KB.
 *
 * Reads:
 *   /graph.json          — node + link data (always generated by preprocessor)
 *   /graph-settings.json — vault-wide defaults from .bloob/graph.yaml
 *
 * Per-page settings come from data attributes on .graph-visualizer containers:
 *   data-current-page    — this page's URL (e.g. "/recipes/chai/")
 *   data-page-settings   — JSON from frontmatter graph: key (set by layout template)
 *   data-graph-settings  — JSON from ```graph code fence (set by build-time transform)
 *   data-graph-position  — "inline" if set by code fence; absent for layout-placed containers
 */

const FORCE_GRAPH_CDN =
  "https://fastly.jsdelivr.net/npm/force-graph@1.43.0/dist/force-graph.min.js";

// ─── Settings ─────────────────────────────────────────────────────────────────

const DEFAULTS = {
  only_if_linked: true,
  depth: 2,
  show_full_graph: true,
  show_tags: false,  // off by default; toggle via the "Show tags" button
  colors: {},
};

// ─── CDN loader ───────────────────────────────────────────────────────────────

function loadForceGraph() {
  return new Promise((resolve, reject) => {
    if (window.ForceGraph) {
      resolve(window.ForceGraph);
      return;
    }
    const script = document.createElement("script");
    script.src = FORCE_GRAPH_CDN;
    script.onload = () => resolve(window.ForceGraph);
    script.onerror = () =>
      reject(new Error("Failed to load force-graph from CDN"));
    document.head.appendChild(script);
  });
}

// ─── Data fetching (shared, cached) ───────────────────────────────────────────

let _graphDataPromise = null;
let _graphSettingsPromise = null;

function fetchGraphData() {
  if (!_graphDataPromise) {
    _graphDataPromise = fetch("/graph.json")
      .then((r) => r.json())
      .catch(() => ({ nodes: [], links: [] }));
  }
  return _graphDataPromise;
}

function fetchGraphSettings() {
  if (!_graphSettingsPromise) {
    _graphSettingsPromise = fetch("/graph-settings.json")
      .then((r) => r.json())
      .catch(() => ({}));
  }
  return _graphSettingsPromise;
}

// ─── Color helpers ────────────────────────────────────────────────────────────

function hexToRgba(hex, alpha) {
  if (!hex || !hex.startsWith("#")) return hex;
  let h = hex.slice(1);
  if (h.length === 3) h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2];
  const r = parseInt(h.slice(0, 2), 16);
  const g = parseInt(h.slice(2, 4), 16);
  const b = parseInt(h.slice(4, 6), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

// ─── CSS variable helpers ─────────────────────────────────────────────────────

function cssVar(name) {
  return getComputedStyle(document.documentElement)
    .getPropertyValue(name)
    .trim();
}

function resolveColors(overrides = {}) {
  return {
    node:           overrides.node           || cssVar("--accent-color") || "#d2691e",
    node_current:   overrides.node_current   || cssVar("--accent-dark")  || "#8b4513",
    node_tag:       overrides.node_tag       || cssVar("--accent-muted") || "#7a9e7e",
    node_dim:       overrides.node_dim       || "rgba(180,160,140,0.3)",
    link:           overrides.link           || cssVar("--text-light")   || "#666666",
    link_highlight: overrides.link_highlight || cssVar("--accent-color") || "#d2691e",
    link_dim:       overrides.link_dim       || "rgba(180,160,140,0.12)",
    text:           overrides.text           || cssVar("--text-color")   || "#333333",
    bg:             overrides.bg             || cssVar("--bg-color")     || "#fffaf0",
  };
}

// ─── Data filtering ───────────────────────────────────────────────────────────

function filterTags(graphData, showTags) {
  if (showTags) return graphData;
  const tagIds = new Set(
    graphData.nodes.filter((n) => n.type === "tag").map((n) => n.id)
  );
  return {
    nodes: graphData.nodes.filter((n) => n.type !== "tag"),
    links: graphData.links.filter((l) => {
      const s = typeof l.source === "object" ? l.source.id : l.source;
      const t = typeof l.target === "object" ? l.target.id : l.target;
      return !tagIds.has(s) && !tagIds.has(t);
    }),
  };
}

/**
 * BFS to collect nodes within `depth` hops of currentUrl (undirected).
 */
function getLocalGraph(graphData, currentUrl, depth) {
  const normalise = (u) => (u.endsWith("/") ? u : u + "/");
  const current = normalise(currentUrl);

  const visited = new Set([current]);
  let frontier = [current];

  for (let hop = 0; hop < depth; hop++) {
    const next = [];
    for (const url of frontier) {
      for (const link of graphData.links) {
        const s = normalise(typeof link.source === "object" ? link.source.id : link.source);
        const t = normalise(typeof link.target === "object" ? link.target.id : link.target);
        const neighbor = s === url ? t : t === url ? s : null;
        if (neighbor && !visited.has(neighbor)) {
          visited.add(neighbor);
          next.push(neighbor);
        }
      }
    }
    frontier = next;
    if (!frontier.length) break;
  }

  const nodes = graphData.nodes.filter((n) => visited.has(normalise(n.id)));
  const nodeIds = new Set(nodes.map((n) => normalise(n.id)));
  const links = graphData.links.filter((l) => {
    const s = normalise(typeof l.source === "object" ? l.source.id : l.source);
    const t = normalise(typeof l.target === "object" ? l.target.id : l.target);
    return nodeIds.has(s) && nodeIds.has(t);
  });

  return { nodes, links };
}

// ─── Adjacency map ────────────────────────────────────────────────────────────

function buildAdjacency(data) {
  const adj = new Map();
  for (const node of data.nodes) adj.set(node.id, new Set());
  for (const link of data.links) {
    const s = typeof link.source === "object" ? link.source.id : link.source;
    const t = typeof link.target === "object" ? link.target.id : link.target;
    if (adj.has(s)) adj.get(s).add(t);
    if (adj.has(t)) adj.get(t).add(s);
  }
  return adj;
}

// ─── Physics setup (shared) ───────────────────────────────────────────────────

function applyPhysics(graph, linkDistance) {
  graph.d3Force("charge").strength(-300);
  if (graph.d3Force("center")) graph.d3Force("center").strength(0.05);
  if (graph.d3Force("link")) graph.d3Force("link").distance(linkDistance).strength(0.5);
}

// ─── Node painter (shared) ────────────────────────────────────────────────────

/**
 * Always uses mode "after" so force-graph keeps full pointer hit-testing on
 * every node. The glow ring is drawn first (below the default node circle)
 * by painting a larger filled circle, then the label on top.
 */
function makeNodePainter(colors, getHovered, adj, opts = {}) {
  const { maxChars = 30, nodeRelSize = 4, nodeValDefault = 3 } = opts;
  // Labels use a fixed screen-space size so they're always readable regardless of zoom.
  // We achieve this by dividing the desired pixel size by globalScale (canvas transform).
  const LABEL_PX = 11; // desired label size in screen pixels

  return function paintNode(node, ctx, globalScale) {
    const hoveredNode = getHovered();
    const isHovered   = hoveredNode && node.id === hoveredNode.id;
    const isNeighbor  = hoveredNode && adj.get(hoveredNode.id)?.has(node.id);
    const isDimmed    = hoveredNode && !isHovered && !isNeighbor;

    // Glow ring for hovered node
    if (isHovered) {
      const r = Math.sqrt(node.nodeVal || nodeValDefault) * nodeRelSize + 4;
      ctx.beginPath();
      ctx.arc(node.x, node.y, r, 0, 2 * Math.PI);
      ctx.strokeStyle = hexToRgba(colors.node_current, 0.5);
      ctx.lineWidth = 2 / globalScale;
      ctx.stroke();
    }

    if (isDimmed) return;

    // Label always visible — fixed screen-space size
    const rawLabel = node.title || node.id;
    const label = rawLabel.length > maxChars
      ? rawLabel.slice(0, maxChars - 1) + "…"
      : rawLabel;
    const fs = LABEL_PX / globalScale;
    ctx.font = `${fs}px ${cssVar("--font-heading") || "sans-serif"}`;
    const tw = ctx.measureText(label).width;
    const pad = 2 / globalScale;
    const nodeRadius = Math.sqrt(node.nodeVal || nodeValDefault) * nodeRelSize;
    const bx = node.x - tw / 2 - pad;
    const by = node.y + nodeRadius + (2 / globalScale);

    ctx.fillStyle = hexToRgba(colors.bg, 0.82);
    ctx.fillRect(bx, by, tw + pad * 2, fs + pad * 2);

    ctx.fillStyle = colors.text;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText(label, node.x, by + pad);
  };
}

// ─── Hover tooltip (shared) ───────────────────────────────────────────────────

/**
 * Simple mouse-following tooltip appended to document.body.
 * Avoids all coordinate conversion problems.
 * Returns { attach(canvasEl), show(node), hide() }.
 */
function makeTooltip() {
  const el = document.createElement("div");
  el.style.cssText = [
    "position:fixed",
    "pointer-events:none",
    "display:none",
    "z-index:9999",
    "background:var(--bg-color,#fffaf0)",
    "border:1px solid var(--border-color,#e0d8cc)",
    "border-radius:6px",
    "padding:6px 8px",
    "box-shadow:0 2px 8px rgba(0,0,0,0.18)",
    "width:150px",
    "font-family:var(--font-body,sans-serif)",
    "font-size:12px",
    "color:var(--text-color,#333)",
    "line-height:1.4",
  ].join(";");
  document.body.appendChild(el);

  // Track mouse position on the canvas element
  function attach(canvasEl) {
    canvasEl.addEventListener("mousemove", (e) => {
      if (el.style.display === "none") return;
      el.style.left = (e.clientX + 14) + "px";
      el.style.top  = (e.clientY - el.offsetHeight - 14) + "px";
    });
    canvasEl.addEventListener("mouseleave", () => hide());
  }

  function show(node, e) {
    el.innerHTML = "";

    if (node.image) {
      const img = document.createElement("img");
      img.src = node.image;
      img.alt = "";
      img.style.cssText = "display:block;width:100%;max-height:90px;object-fit:cover;border-radius:3px;margin-bottom:5px;";
      el.appendChild(img);
    }

    const nameEl = document.createElement("div");
    nameEl.style.cssText = "font-weight:600;word-break:break-word;text-align:center;";
    nameEl.textContent = node.title || node.id;
    el.appendChild(nameEl);

    el.style.display = "block";
  }

  function hide() {
    el.style.display = "none";
  }

  return { attach, show, hide };
}

// ─── Inline graph ─────────────────────────────────────────────────────────────

function renderGraph(ForceGraph, container, graphData, currentUrl, settings) {
  const colors = resolveColors(settings.colors);
  const normalise = (u) => (u.endsWith("/") ? u : u + "/");
  const current = normalise(currentUrl);

  let showTags = settings.show_tags;
  let localData = getLocalGraph(filterTags(graphData, showTags), currentUrl, settings.depth);

  // Hide if only_if_linked and this page has no connections
  if (settings.only_if_linked && localData.nodes.length <= 1) {
    container.style.display = "none";
    return;
  }

  // --- Build container structure ---
  const header = document.createElement("div");
  header.className = "graph-header";

  const title = document.createElement("span");
  title.className = "graph-title";
  title.textContent = "Connections";
  header.appendChild(title);

  // Tags toggle
  const tagsBtn = document.createElement("button");
  tagsBtn.className = "graph-full-btn";
  tagsBtn.textContent = showTags ? "Hide tags" : "Show tags";
  header.appendChild(tagsBtn);

  if (settings.show_full_graph) {
    const fullBtn = document.createElement("button");
    fullBtn.className = "graph-full-btn";
    fullBtn.textContent = "Full graph";
    fullBtn.addEventListener("click", () =>
      openFullGraph(ForceGraph, filterTags(graphData, showTags), currentUrl, settings)
    );
    header.appendChild(fullBtn);
  }

  const canvasDiv = document.createElement("div");
  canvasDiv.className = "graph-canvas";
  canvasDiv.style.touchAction = "none"; // let force-graph handle pinch-zoom

  container.appendChild(header);
  container.appendChild(canvasDiv);

  // --- Tooltip ---
  const tooltip = makeTooltip();

  // --- Graph state ---
  let hoveredNode = null;
  let adj = buildAdjacency(localData);
  const width = container.offsetWidth || 500;
  const height = 340;

  function nodeColor(node) {
    if (hoveredNode) {
      if (node.id === hoveredNode.id) return colors.node_current;
      if (adj.get(hoveredNode.id)?.has(node.id)) return colors.node;
      return colors.node_dim;
    }
    if (normalise(node.id) === current) return colors.node_current;
    if (node.type === "tag") return colors.node_tag;
    return colors.node;
  }

  function linkColor(link) {
    if (!hoveredNode) return hexToRgba(colors.link, 0.65);
    const s = typeof link.source === "object" ? link.source.id : link.source;
    const t = typeof link.target === "object" ? link.target.id : link.target;
    if (s === hoveredNode.id || t === hoveredNode.id) return hexToRgba(colors.link_highlight, 0.9);
    return colors.link_dim;
  }

  function linkWidth(link) {
    if (!hoveredNode) return 1.5;
    const s = typeof link.source === "object" ? link.source.id : link.source;
    const t = typeof link.target === "object" ? link.target.id : link.target;
    return (s === hoveredNode.id || t === hoveredNode.id) ? 3 : 0.6;
  }

  const graph = ForceGraph()(canvasDiv)
    .graphData(localData)
    .nodeId("id")
    .nodeLabel(() => "")  // disable native tooltip; we use our own HTML tooltip
    .nodeVal((n) => n.nodeVal || 3)
    .nodeColor(nodeColor)
    .nodeRelSize(4)
    .linkColor(linkColor)
    .linkWidth(linkWidth)
    .backgroundColor(colors.bg)
    .width(width)
    .height(height)
    .nodeCanvasObjectMode(() => "after")
    .nodeCanvasObject(makeNodePainter(colors, () => hoveredNode, adj, { nodeRelSize: 4, nodeValDefault: 3 }))
    .onNodeHover((node) => {
      hoveredNode = node || null;
      if (node) tooltip.show(node);
      else tooltip.hide();
    })
    .onNodeClick((node) => { window.location.href = node.id; })
    .d3AlphaDecay(0.02)
    .d3VelocityDecay(0.35)
    .autoPauseRedraw(false);

  // Wire mouse tracking after force-graph creates its canvas
  setTimeout(() => {
    const canvas = canvasDiv.querySelector("canvas");
    if (canvas) tooltip.attach(canvas);
  }, 100);

  applyPhysics(graph, 80);
  graph.warmupTicks(80);
  // Fit all nodes into view after warmup
  setTimeout(() => graph.zoomToFit(400, 20), 50);

  // Tags toggle handler — reload graph data in place
  tagsBtn.addEventListener("click", () => {
    showTags = !showTags;
    tagsBtn.textContent = showTags ? "Hide tags" : "Show tags";
    localData = getLocalGraph(filterTags(graphData, showTags), currentUrl, settings.depth);
    adj = buildAdjacency(localData);
    graph.graphData(localData);
    applyPhysics(graph, 80);
    graph.warmupTicks(60);
    setTimeout(() => graph.zoomToFit(400, 20), 50);
  });
}

// ─── Full graph modal ─────────────────────────────────────────────────────────

function openFullGraph(ForceGraph, graphData, currentUrl, settings) {
  const colors = resolveColors(settings.colors);
  const normalise = (u) => (u.endsWith("/") ? u : u + "/");
  const current = normalise(currentUrl);

  let showTags = settings.show_tags;
  let activeData = filterTags(graphData, showTags);

  const overlay = document.createElement("div");
  overlay.className = "graph-modal-overlay";

  const modal = document.createElement("div");
  modal.className = "graph-modal";

  const closeBtn = document.createElement("button");
  closeBtn.className = "graph-modal-close";
  closeBtn.setAttribute("aria-label", "Close full graph");
  closeBtn.textContent = "×";
  closeBtn.addEventListener("click", () => overlay.remove());

  // Tags toggle inside modal header area
  const tagsBtn = document.createElement("button");
  tagsBtn.className = "graph-full-btn";
  tagsBtn.style.cssText = "position:absolute;top:10px;left:14px;z-index:1;";
  tagsBtn.textContent = showTags ? "Hide tags" : "Show tags";

  const canvasDiv = document.createElement("div");
  canvasDiv.className = "graph-modal-canvas";
  canvasDiv.style.touchAction = "none"; // let force-graph handle pinch-zoom

  modal.appendChild(closeBtn);
  modal.appendChild(tagsBtn);
  modal.appendChild(canvasDiv);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  overlay.addEventListener("click", (e) => { if (e.target === overlay) overlay.remove(); });
  document.addEventListener("keydown", (e) => { if (e.key === "Escape") overlay.remove(); }, { once: true });

  let fg = null;
  let hoveredNode = null;
  let adj = buildAdjacency(activeData);

  function nodeColor(node) {
    if (hoveredNode) {
      if (node.id === hoveredNode.id) return colors.node_current;
      if (adj.get(hoveredNode.id)?.has(node.id)) return colors.node;
      return colors.node_dim;
    }
    if (normalise(node.id) === current) return colors.node_current;
    if (node.type === "tag") return colors.node_tag;
    return colors.node;
  }

  function linkColor(link) {
    if (!hoveredNode) return hexToRgba(colors.link, 0.65);
    const s = typeof link.source === "object" ? link.source.id : link.source;
    const t = typeof link.target === "object" ? link.target.id : link.target;
    if (s === hoveredNode.id || t === hoveredNode.id) return hexToRgba(colors.link_highlight, 0.9);
    return colors.link_dim;
  }

  function linkWidth(link) {
    if (!hoveredNode) return 1.5;
    const s = typeof link.source === "object" ? link.source.id : link.source;
    const t = typeof link.target === "object" ? link.target.id : link.target;
    return (s === hoveredNode.id || t === hoveredNode.id) ? 3 : 0.6;
  }

  // Tooltip for full graph
  const tooltip = makeTooltip();
  // Hide tooltip when modal closes
  overlay.addEventListener("click", () => tooltip.hide());
  document.addEventListener("keydown", () => tooltip.hide(), { once: true });

  setTimeout(() => {
    const width = modal.clientWidth || 820;
    const height = modal.clientHeight || 600;
    canvasDiv.style.width = width + "px";
    canvasDiv.style.height = height + "px";

    const NODE_REL_SIZE = 6;
    fg = ForceGraph()(canvasDiv)
      .graphData(activeData)
      .nodeId("id")
      .nodeLabel(() => "")  // disable native tooltip; we use our own HTML tooltip
      .nodeVal((n) => n.nodeVal || 3)
      .nodeColor(nodeColor)
      .nodeRelSize(NODE_REL_SIZE)
      .linkColor(linkColor)
      .linkWidth(linkWidth)
      .backgroundColor(colors.bg)
      .width(width)
      .height(height)
      .nodeCanvasObjectMode(() => "after")
      .nodeCanvasObject(makeNodePainter(colors, () => hoveredNode, adj, { nodeRelSize: NODE_REL_SIZE, nodeValDefault: 3 }))
      .onNodeHover((node) => {
        hoveredNode = node || null;
        if (node) tooltip.show(node);
        else tooltip.hide();
      })
      .onNodeClick((node) => { overlay.remove(); window.location.href = node.id; })
      .d3AlphaDecay(0.02)
      .d3VelocityDecay(0.35)
      .autoPauseRedraw(false);

    // Tighter physics for full graph (95 nodes): less charge + shorter links
    fg.d3Force("charge").strength(-120);
    if (fg.d3Force("center")) fg.d3Force("center").strength(0.08);
    if (fg.d3Force("link")) fg.d3Force("link").distance(45).strength(0.6);
    fg.warmupTicks(150);
    setTimeout(() => {
      fg.zoomToFit(400, 30);
      const canvas = canvasDiv.querySelector("canvas");
      if (canvas) tooltip.attach(canvas);
    }, 50);

    tagsBtn.addEventListener("click", () => {
      showTags = !showTags;
      tagsBtn.textContent = showTags ? "Hide tags" : "Show tags";
      activeData = filterTags(graphData, showTags);
      adj = buildAdjacency(activeData);
      fg.graphData(activeData);
      fg.d3Force("charge").strength(-120);
      if (fg.d3Force("center")) fg.d3Force("center").strength(0.08);
      if (fg.d3Force("link")) fg.d3Force("link").distance(45).strength(0.6);
      fg.warmupTicks(80);
      setTimeout(() => fg.zoomToFit(400, 30), 50);
    });
  }, 50);
}

// ─── Init ─────────────────────────────────────────────────────────────────────

async function init() {
  const containers = document.querySelectorAll(".graph-visualizer");
  if (!containers.length) return;

  let ForceGraph, graphData, siteSettings;
  try {
    [ForceGraph, graphData, siteSettings] = await Promise.all([
      loadForceGraph(),
      fetchGraphData(),
      fetchGraphSettings(),
    ]);
  } catch (e) {
    console.warn("[graph] Failed to initialise:", e.message);
    return;
  }

  for (const container of containers) {
    const currentUrl = container.dataset.currentPage || window.location.pathname;

    let pageSettings = {};
    try { if (container.dataset.pageSettings) pageSettings = JSON.parse(container.dataset.pageSettings); } catch {}

    let instanceSettings = {};
    try { if (container.dataset.graphSettings) instanceSettings = JSON.parse(container.dataset.graphSettings); } catch {}

    const settings = {
      ...DEFAULTS,
      ...siteSettings,
      ...pageSettings,
      ...instanceSettings,
      colors: {
        ...(siteSettings.colors || {}),
        ...(pageSettings.colors || {}),
        ...(instanceSettings.colors || {}),
      },
    };

    renderGraph(ForceGraph, container, graphData, currentUrl, settings);
  }
}

document.addEventListener("DOMContentLoaded", init);
