# Visualizer Architecture

**Status:** Modular architecture with auto-discovery. Two runtime visualizers: checkbox-tracker, page-preview.  
**Location:** `docs/architecture/`  
**Updated:** 2026-02-09

Visualizers are the core of Bloob Haus - "little machines" that transform text into visual/interactive experiences. This document describes how the visualizer system works.

---

## Core Concepts

| Concept | Definition |
|---------|------------|
| **Marble** | A note/object that can be held, shared, embedded |
| **Visualizer** | A machine that transforms content into an experience |
| **Room** | A container for marbles (maps to folders/sections) |
| **Haus** | A user's site (subdomain like `leon.bloob.haus`) |

---

## Visualizer Design Principle

**All visualizers MUST be pure functions:**

1. `parser(markdown) → data` - No side effects, JSON-serializable output
2. `renderer(data) → html` - No DOM manipulation, returns string

This enables:
- Build-time static generation (Eleventy)
- Instant browser preview (same code, different context)  
- Obsidian plugin (same parser, platform-specific renderer)
- Future: server-side rendering, API endpoints, etc.

**Never put DOM operations in parser or renderer.**
**Never put file system operations in parser or renderer.**

---

## Two Types of Visualizers

### Build-time Visualizers
Run during preprocessing (Node.js). Parse custom markdown syntax into data, then render to HTML.

**Key decision:** Build-time parsers run in the **preprocessor** (before markdown-it), not in Eleventy's `addTransform` (after). This ensures parsers receive raw markdown, so the same parser code works in Eleventy, browser preview, and Obsidian plugins. See [DECISIONS.md](../implementation-plans/DECISIONS.md) for full rationale.

```
raw markdown with ::: timeline
    ↓ parser.js (during preprocess-content.js) → structured data
    ↓ renderer.js (data → HTML string)
modified markdown (custom syntax replaced with HTML)
    ↓ markdown-it renders remaining standard markdown
final HTML page
```

**Examples:** Timeline, yoga sequence, recipe card layout

**When to use:** When you need to parse custom markdown syntax (e.g., `::: timeline`, fenced code blocks) or generate structured data for the page.

### Runtime Visualizers
Run in the browser (JS + CSS). Enhance already-rendered HTML with interactivity.

```
rendered HTML in the DOM
    ↓ browser.js (DOM events, localStorage, etc.)
interactive experience
```

**Examples:** Checkbox tracker, link previews, graph visualization

**When to use:** When you need client-side interactivity, state persistence, or dynamic behavior. Standard markdown syntax (like `- [ ]` for checkboxes) is handled by markdown-it plugins, not by visualizers.

### Hybrid Visualizers
Some need both: build-time generates data, runtime renders it interactively.

**Examples:** 
- Graph: build-time generates `links.json`, runtime renders D3 visualization
- Timeline: build-time parses `::: timeline` blocks → JSON, runtime renders interactive timeline

---

## Folder Structure

```
lib/visualizers/                        ← Source of truth for all visualizer code
├── checkbox-tracker/                   ← Each visualizer is a self-contained package
│   ├── manifest.json                   ← Metadata, activation method, settings schema
│   ├── index.js                        ← Module entry point (exports type, name, transform)
│   ├── browser.js                      ← Runtime: DOM events, localStorage (side effects)
│   └── styles.css                      ← Visualizer-specific CSS
├── timeline/                           ← (future) Build-time visualizer example
│   ├── manifest.json
│   ├── index.js
│   ├── parser.js                       ← Pure: markdown → structured data
│   ├── renderer.js                     ← Pure: data → HTML string
│   ├── browser.js                      ← Runtime interactivity (optional)
│   └── styles.css
└── ...

scripts/
├── preprocess-content.js               ← Orchestrates build-time visualizer parsers
├── bundle-visualizers.js               ← esbuild: bundles browser.js + copies CSS
└── utils/

src/
├── _data/
│   └── visualizers.json                ← Generated manifest (auto-includes in templates)
├── assets/                             ← Generated by bundle-visualizers.js
│   ├── css/visualizers/
│   │   ├── checkbox-tracker.css        ← Copied from lib/visualizers/
│   │   └── page-preview.css            ← Copied from lib/visualizers/
│   └── js/visualizers/
│       ├── checkbox-tracker.js         ← Bundled from lib/visualizers/ via esbuild
│       └── page-preview.js             ← Bundled from lib/visualizers/ via esbuild
├── _includes/partials/
│   ├── head.njk                        ← Loops over visualizers data to include CSS
│   └── scripts.njk                     ← Loops over visualizers data to include JS

eleventy.config.js                      ← addTransform for post-render HTML modifications
```

**Adding a new visualizer = adding a new folder in `lib/visualizers/`.** No changes to any other file needed — the bundler auto-discovers folders, writes a manifest, and templates auto-include from that manifest.

---

## Visualizer Manifest Format

Each visualizer declares its metadata:

```json
{
  "name": "checkbox-tracker",
  "type": "runtime",
  "version": "1.0.0",
  "description": "Enables clickable checkboxes with persistent state",
  "activation": {
    "method": "auto-detect",
    "pattern": "input[type=checkbox]"
  },
  "files": {
    "js": "checkbox-tracker.js",
    "css": "checkbox-tracker.css"
  },
  "settings": {
    "undoWindowMs": {
      "type": "number",
      "default": 60000,
      "description": "How long the undo window stays open (ms)"
    }
  }
}
```

---

## Activation Methods (with Precedence)

Visualizers can be activated in four ways. When conflicts occur, higher precedence wins:

| Precedence | Method | Scope | Example |
|------------|--------|-------|---------|
| 1 (highest) | **Page frontmatter** | Single page | `visualizers: [timeline, graph]` |
| 2 | **Folder config** | All pages in folder | `.bloob/visualizers.json` |
| 3 | **Auto-detection** | Pages matching pattern | Checkbox tracker detects `- [ ]` |
| 4 (lowest) | **Global config** | Entire site | `hugo/config.yaml` or webapp settings |

**Example frontmatter:**
```yaml
---
title: My Timeline
visualizers:
  - timeline
  - graph
timeline:
  style: horizontal
---
```

**Example folder config (`.bloob/visualizers.json`):**
```json
{
  "visualizers": ["recipe-card"],
  "recipe-card": {
    "showScalingCalculator": true
  }
}
```

---

## Build Process Integration (Approach A - Chosen)

**Decision:** Resolve visualizers at build time, not runtime.

During preprocessing:
1. Scan all pages for frontmatter `visualizers` declarations
2. Scan all folders for `.bloob/visualizers.json` configs
3. Run auto-detection patterns across content
4. Check global config for site-wide visualizers
5. Generate `active-visualizers.json` manifest mapping pages → visualizers
6. Run build-time visualizers on relevant pages
7. Hugo uses manifest to include only needed CSS/JS per page (or bundle all active ones)

**Why this approach:**
- Smaller page payloads (don't load unused visualizers)
- Build fails fast if visualizer is missing
- Clear audit trail of what's active where

**Alternative considered (Approach B - Runtime resolution):**
- Include ALL runtime visualizers on every page
- Each visualizer auto-detects if it should activate
- Simpler but doesn't scale (20 visualizers = bloated pages)

---

## Site-Wide Visualizers (Webapp Feature)

For the webapp (Phase 3+), users should be able to:
1. Browse a **visualizer library** of pre-built visualizers
2. **Enable visualizers** for their site without coding
3. **Configure settings** via UI (maps to global config)
4. **Upload custom visualizers** (JS/CSS files with manifest)

**Storage:** Visualizer code lives in Bloob Haus infrastructure, not user's repo. User's config just references which visualizers are active.

```json
// User's site config (stored in webapp DB or .bloob/config.json)
{
  "visualizers": {
    "enabled": ["checkbox-tracker", "link-preview", "graph"],
    "settings": {
      "checkbox-tracker": { "undoWindowMs": 30000 },
      "graph": { "showGlobal": false }
    }
  }
}
```

---

## Auto-Detection Syntax (Needs Further Design)

Auto-detection should be careful and explicit. Ideas to explore:

| Pattern | Visualizer | Notes |
|---------|------------|-------|
| `- [ ]` in content | checkbox-tracker | Current implementation |
| `\| date \| event \|` tables | timeline | Need to distinguish from regular tables |
| `[[yoga:pose-name]]` | yoga-sequence | Namespaced wiki-links? |
| Code blocks with language | various | ` ```timeline ` as trigger? |

**Open question:** Should auto-detection require opt-in at folder/site level? To prevent unexpected behavior.

---

## Current Implementation (Post-Migration M4)

```
lib/visualizers/
├── checkbox-tracker/
│   ├── manifest.json       ← type: "runtime", activation: auto-detect
│   ├── index.js            ← exports type, name; no-op transform (runtime-only)
│   ├── browser.js          ← DOM: enables checkboxes, localStorage persistence, reset button
│   └── styles.css          ← Custom checkbox styling, floating reset button
├── page-preview/
│   ├── manifest.json       ← type: "runtime", activation: auto-detect
│   ├── index.js            ← exports type, name; no-op transform (runtime-only)
│   ├── browser.js          ← DOM: preview button + modal overlay via fetch()
│   └── styles.css          ← Preview button, modal overlay, responsive styles
```

**Build pipeline:**
1. `scripts/bundle-visualizers.js` — auto-discovers `lib/visualizers/*/`, bundles with esbuild, writes `src/_data/visualizers.json` manifest
2. Nunjucks templates (`head.njk`, `scripts.njk`) — loop over `visualizers.json` to auto-include CSS/JS
3. `eleventy.config.js` — auto-loads visualizer modules, registers `addTransform` for build-time visualizers
4. `markdown-it-task-lists` plugin — converts `- [ ]` to `<input type="checkbox">` (markdown parser layer)
5. `browser.js` — runtime enhancement (interactivity, persistence)

**What's working:**
- Checkbox tracker: styled checkboxes, click persistence, floating reset button with undo
- Page preview: eye icon button on recipe cards, tag pages, search results; modal overlay with fetched content
- Auto-discovery: new visualizer = new folder, no config changes needed anywhere
- esbuild bundling with sourcemaps in dev
- Auto-generated CSS/JS includes via `visualizers.json` data file (no more hardcoded `<link>`/`<script>` tags)

**Not yet implemented:**
- Per-page visualizer activation (frontmatter `visualizers:` field)
- Folder config (`.bloob/visualizers.json`)
- Build-time visualizer integration in preprocessor
- Per-page CSS/JS inclusion (currently all visualizers loaded on every page)

---

## Implementation Phases

| Phase | Milestone |
|-------|-----------|
| Phase 1 ✓ | Checkbox tracker working (Hugo) |
| M4 ✓ | Modular visualizer architecture, esbuild bundling, auto-discovery (Eleventy) |
| ✓ | Page preview visualizer — modal overlay with preview button on cards/search/tags |
| ✓ | Auto-generated CSS/JS includes via `visualizers.json` data file |
| Next | Build-time visualizer integration in preprocessor (first candidate: timeline or recipe-card) |
| Next | Per-page visualizer activation via frontmatter |
| Future | Full manifest system, folder configs, per-page CSS/JS inclusion |
| Future | Webapp visualizer library, user uploads, UI configuration |

---

## Related Documents

- [Magic Machines Architecture](magic-machines.md) - The "write" counterpart to visualizers
- [Search Architecture](search.md) - Search, tags, and Pagefind
- [Recipe Scaling Plan](../implementation-plans/phases/phase-2/2026-02-03_recipe-scaling.md) - Example hybrid visualizer
